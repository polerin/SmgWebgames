{"mappings":"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","sources":["apps/game/src/main.ts","apps/game/src/resources.ts","node_modules/@parcel/runtime-js/lib/runtime-d50fcb8924f97531.js","apps/game/src/level.ts","apps/game/src/player.ts"],"sourcesContent":["import { Color, DisplayMode, Engine, FadeInOut } from \"excalibur\";\nimport { mainLoader } from \"./resources.js\";\nimport { MyLevel } from \"./level.js\";\n\n// Goal is to keep main.ts small and just enough to configure the engine\n\nconst game = new Engine({\n  width: 800, // Logical width and height in game pixels\n  height: 600,\n  displayMode: DisplayMode.FitScreenAndFill, // Display mode tells excalibur how to fill the window\n  pixelArt: true, // pixelArt will turn on the correct settings to render pixel art without jaggies or shimmering artifacts\n  scenes: {\n    start: MyLevel\n  },\n  // physics: {\n  //   solver: SolverStrategy.Realistic,\n  //   substep: 5 // Sub step the physics simulation for more robust simulations\n  // },\n  // fixedUpdateTimestep: 16 // Turn on fixed update timestep when consistent physic simulation is important\n});\n\ngame.start('start', { // name of the start scene 'start'\n  loader: mainLoader, // Optional loader (but needed for loading images/sounds)\n  inTransition: new FadeInOut({ // Optional in transition\n    duration: 1000,\n    direction: 'in',\n    color: Color.ExcaliburBlue\n  })\n}).then(() => {\n  // Do something after the game starts\n});","import { ImageSource, Loadable, Loader } from \"excalibur\";\nimport swordPath from './images/sword.png';\n\ntype ResourceMapKey = 'image' | 'audio';\n\nconst loader = new Loader();\nconst resourceMap: Record<ResourceMapKey, Record<string, string>> = {\n  image: {\n    Sword: swordPath,\n  },\n  audio: {\n\n  }\n};\n\nconst resourceBuffer: Record<string, Loadable<any>> = {};\n\nconst addImageDef = (resource:[name: string, path: string]): void => {\n  const constructedPath = (new URL(resource[1])).pathname;\n  console.info(`Adding resource ${resource[0]} : ${constructedPath}`);\n\n  resourceBuffer[resource[0]] = new ImageSource(constructedPath);\n\n  loader.addResource(resourceBuffer[resource[0]]);\n};\n\nObject.entries(resourceMap.image).forEach(addImageDef);\n\n\n\n// We build a loader and add all of our resources to the boot loader\n// You can build your own loader by extending DefaultLoader\nfor (const res of Object.values(resourceBuffer)) {\n  loader.addResource(res);\n}\n\n// It is convenient to put your resources in one place\nconst Resources = {... resourceBuffer } as const; \n\nexport {\n  Resources,\n  loader as mainLoader,\n}\n","module.exports = new __parcel__URL__(\"sword.0b40f6ad.png\").toString();","\n//import { DefaultLoader, Engine, ExcaliburGraphicsContext, Scene, SceneActivationContext } from \"excalibur\";\nimport { Engine, Scene } from \"excalibur\";\n\nimport { Player } from \"./player.js\";\n\nexport class MyLevel extends Scene {\n    override onInitialize(_engine: Engine): void {\n        // Scene.onInitialize is where we recommend you perform the composition for your game\n        const player = new Player();\n        this.add(player); // Actors need to be added to a scene to be drawn\n    }\n\n    // override onPreLoad(loader: DefaultLoader): void {\n    //     // Add any scene specific resources to load\n    // }\n\n    // override onActivate(context: SceneActivationContext<unknown>): void {\n    //     // Called when Excalibur transitions to this scene\n    //     // Only 1 scene is active at a time\n    // }\n\n    // override onDeactivate(context: SceneActivationContext): void {\n    //     // Called when Excalibur transitions away from this scene\n    //     // Only 1 scene is active at a time\n    // }\n\n    // override onPreUpdate(engine: Engine, elapsedMs: number): void {\n    //     // Called before anything updates in the scene\n    // }\n\n    // override onPostUpdate(engine: Engine, elapsedMs: number): void {\n    //     // Called after everything updates in the scene\n    // }\n\n    // override onPreDraw(ctx: ExcaliburGraphicsContext, elapsedMs: number): void {\n    //     // Called before Excalibur draws to the screen\n    // }\n\n    // override onPostDraw(ctx: ExcaliburGraphicsContext, elapsedMs: number): void {\n    //     // Called after Excalibur draws to the screen\n    // }\n}","\nimport { Actor, vec } from \"excalibur\";\n// import { Actor, Collider, CollisionContact, Engine, Side, vec } from \"excalibur\";\n\nimport { Resources } from \"./resources.js\";\n\n// Actors are the main unit of composition you'll likely use, anything that you want to draw and move around the screen\n// is likely built with an actor\n\n// They contain a bunch of useful components that you might use\n// actor.transform\n// actor.motion\n// actor.graphics\n// actor.body\n// actor.collider\n// actor.actions\n// actor.pointer\n\n\nexport class Player extends Actor {\n  constructor() {\n    super({\n      // Giving your actor a name is optional, but helps in debugging using the dev tools or debug mode\n      // https://github.com/excaliburjs/excalibur-extension/\n      // Chrome: https://chromewebstore.google.com/detail/excalibur-dev-tools/dinddaeielhddflijbbcmpefamfffekc\n      // Firefox: https://addons.mozilla.org/en-US/firefox/addon/excalibur-dev-tools/\n      name: 'Player',\n      pos: vec(150, 150),\n      width: 100,\n      height: 100,\n      // anchor: vec(0, 0), // Actors default center colliders and graphics with anchor (0.5, 0.5)\n      // collisionType: CollisionType.Active, // Collision Type Active means this participates in collisions read more https://excaliburjs.com/docs/collisiontypes\n    });\n    \n  }\n\n  override onInitialize() {\n    // Generally recommended to stick logic in the \"On initialize\"\n    // This runs before the first update\n    // Useful when\n    // 1. You need things to be loaded like Images for graphics\n    // 2. You need excalibur to be initialized & started \n    // 3. Deferring logic to run time instead of constructor time\n    // 4. Lazy instantiation\n    this.graphics.add(Resources.Sword.toSprite());\n\n    // Actions are useful for scripting common behavior, for example patrolling enemies\n    this.actions.delay(2000);\n    this.actions.repeatForever(ctx => {\n      ctx.moveBy({offset: vec(100, 0), duration: 1000});\n      ctx.moveBy({offset: vec(0, 100), duration: 1000});\n      ctx.moveBy({offset: vec(-100, 0), duration: 1000});\n      ctx.moveBy({offset: vec(0, -100), duration: 1000});\n    });\n\n    // Sometimes you want to click on an actor!\n    this.on('pointerdown', evt => {\n      // Pointer events tunnel in z order from the screen down, you can cancel them!\n      // if (true) {\n      //   evt.cancel();\n      // }\n      console.log('You clicked the actor @', evt.worldPos.toString());\n    });\n  }\n\n  // override onPreUpdate(engine: Engine, elapsedMs: number): void {\n  //   // Put any update logic here runs every frame before Actor builtins\n  // }\n\n  // override onPostUpdate(engine: Engine, elapsedMs: number): void {\n  //   // Put any update logic here runs every frame after Actor builtins\n  // }\n\n  // override onPreCollisionResolve(self: Collider, other: Collider, side: Side, contact: CollisionContact): void {\n  //   // Called before a collision is resolved, if you want to opt out of this specific collision call contact.cancel()\n  // }\n\n  // override onPostCollisionResolve(self: Collider, other: Collider, side: Side, contact: CollisionContact): void {\n  //   // Called every time a collision is resolved and overlap is solved\n  // }\n\n  // override onCollisionStart(self: Collider, other: Collider, side: Side, contact: CollisionContact): void {\n  //   // Called when a pair of objects are in contact\n  // }\n\n  // override onCollisionEnd(self: Collider, other: Collider, side: Side, lastContact: CollisionContact): void {\n  //   // Called when a pair of objects separates\n  // }\n}\n"],"names":[],"version":3,"file":"index.js.map"}